# SwiftResearch ä»•æ§˜æ›¸

## æ¦‚è¦

SwiftResearchã¯ã€SwiftAgentãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ç”¨ã—ãŸAIé§†å‹•ã®ãƒªã‚µãƒ¼ãƒãƒ„ãƒ¼ãƒ«ã§ã™ã€‚Ollamaã‚’ä½¿ç”¨ã—ã¦ãƒšãƒ¼ã‚¸ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’åˆ†æã—ã€**ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯å……è¶³åº¦åˆ¤å®š**ã«ã‚ˆã£ã¦æƒ…å ±åé›†ã®å®Œäº†ã‚’åˆ¤æ–­ã—ã¾ã™ã€‚5ãƒ•ã‚§ãƒ¼ã‚ºæ§‹æˆã§ç›®çš„åˆ†æã‹ã‚‰æœ€çµ‚ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã¾ã§è‡ªå‹•åŒ–ã—ã¾ã™ã€‚

## ä½¿ç”¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒª

| ãƒ©ã‚¤ãƒ–ãƒ©ãƒª | å½¹å‰² |
|-----------|------|
| **SwiftAgent** | ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã€‚Step-basedè¨­è¨ˆã®åŸºç›¤ |
| **Selenops** | Webã‚¯ãƒ­ãƒ¼ãƒªãƒ³ã‚°ã®åŸºç›¤ |
| **RemarkKit** | å…¨ã¦ã®Webã‚¢ã‚¯ã‚»ã‚¹ã€‚HTMLâ†’Markdownå¤‰æ›ã€ãƒªãƒ³ã‚¯æŠ½å‡º |
| **OpenFoundationModels-Ollama** | LLMåˆ†æï¼ˆ@Generableã«ã‚ˆã‚‹æ§‹é€ åŒ–å‡ºåŠ›ï¼‰ |

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### 5ãƒ•ã‚§ãƒ¼ã‚ºæ§‹æˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SearchOrchestratorStep                           â”‚
â”‚                                                                      â”‚
â”‚  Phase 0: INPUT                                                     â”‚
â”‚       â†“                                                             â”‚
â”‚  Phase 1: OBJECTIVE ANALYSIS (ç›®çš„åˆ†æ)                             â”‚
â”‚       - ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ç”Ÿæˆ                                               â”‚
â”‚       - ã‚½ã‚¯ãƒ©ãƒ†ã‚¹çš„è³ªå•åˆ†è§£                                         â”‚
â”‚       - æˆåŠŸåŸºæº–è¨­å®š                                                 â”‚
â”‚       â†“                                                             â”‚
â”‚  Phase 2-4 ãƒ«ãƒ¼ãƒ—                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Phase 2: SEARCH (æ¤œç´¢)                                        â”‚ â”‚
â”‚  â”‚       - ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§æ¤œç´¢ã‚¨ãƒ³ã‚¸ãƒ³æ¤œç´¢                             â”‚ â”‚
â”‚  â”‚       - URLä¸€è¦§å–å¾—                                             â”‚ â”‚
â”‚  â”‚       â†“                                                        â”‚ â”‚
â”‚  â”‚  Phase 3: PARALLEL CONTENT REVIEW (ä¸¦åˆ—ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ¬ãƒ“ãƒ¥ãƒ¼)       â”‚ â”‚
â”‚  â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚ â”‚
â”‚  â”‚       â”‚  CrawlContext (å…±æœ‰çŠ¶æ…‹)            â”‚                   â”‚ â”‚
â”‚  â”‚       â”‚  - URLã‚­ãƒ¥ãƒ¼                        â”‚                   â”‚ â”‚
â”‚  â”‚       â”‚  - æ—¢çŸ¥äº‹å®Ÿ (knownFacts)            â”‚                   â”‚ â”‚
â”‚  â”‚       â”‚  - æœ‰ç”¨ãƒ‰ãƒ¡ã‚¤ãƒ³å­¦ç¿’                 â”‚                   â”‚ â”‚
â”‚  â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚ â”‚
â”‚  â”‚            â†“        â†“        â†“        â†“                        â”‚ â”‚
â”‚  â”‚       [Worker0] [Worker1] [Worker2] [Worker3]                   â”‚ â”‚
â”‚  â”‚       - å„ãƒ¯ãƒ¼ã‚«ãƒ¼: fetch â†’ LLMãƒ¬ãƒ“ãƒ¥ãƒ¼ â†’ DeepCrawl URLè¿½åŠ      â”‚ â”‚
â”‚  â”‚       - æ—¢çŸ¥äº‹å®Ÿã‚’å…±æœ‰ã—ã¦é‡è¤‡æŠ½å‡ºã‚’é˜²æ­¢                        â”‚ â”‚
â”‚  â”‚       â†“                                                        â”‚ â”‚
â”‚  â”‚  Phase 4: SUFFICIENCY CHECK (å……è¶³åº¦ãƒã‚§ãƒƒã‚¯)                    â”‚ â”‚
â”‚  â”‚       - ååˆ† â†’ ãƒ«ãƒ¼ãƒ—çµ‚äº†                                       â”‚ â”‚
â”‚  â”‚       - ä¸ååˆ† â†’ è¿½åŠ ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§ç¶™ç¶š                           â”‚ â”‚
â”‚  â”‚       - è«¦ã‚ â†’ ãƒ«ãƒ¼ãƒ—çµ‚äº†                                       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚       â†“                                                             â”‚
â”‚  Phase 5: RESPONSE BUILDING (å¿œç­”æ§‹ç¯‰)                              â”‚
â”‚       - åé›†æƒ…å ±ã‹ã‚‰æœ€çµ‚ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ                                 â”‚
â”‚       â†“                                                             â”‚
â”‚  AggregatedResult                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè©³ç´°

#### 1. SearchOrchestratorStep

5ãƒ•ã‚§ãƒ¼ã‚ºã‚’çµ±æ‹¬ã™ã‚‹ãƒ¡ã‚¤ãƒ³Stepã€‚

```swift
public struct SearchOrchestratorStep: Step, Sendable {
    typealias Input = SearchQuery
    typealias Output = AggregatedResult
}

public struct SearchQuery: Sendable {
    let objective: String        // èª¿æŸ»ç›®çš„
    let maxVisitedURLs: Int      // è¨ªå•URLæ•°ã®ä¸Šé™ï¼ˆã‚»ãƒ¼ãƒ•ãƒ†ã‚£ãƒªãƒŸãƒƒãƒˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 100ï¼‰
}
```

#### 2. SearchStep

æ¤œç´¢ã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½¿ç”¨ã—ã¦ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰URLãƒªã‚¹ãƒˆã‚’å–å¾—ã™ã‚‹Stepã€‚

```swift
public struct SearchStep: Step, Sendable {
    typealias Input = KeywordSearchInput
    typealias Output = [URL]
}

public struct KeywordSearchInput: Sendable {
    let keyword: String
}
```

**ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°:**
- æ¤œç´¢ã‚¨ãƒ³ã‚¸ãƒ³å†…éƒ¨ãƒªãƒ³ã‚¯ã‚’é™¤å¤–ï¼ˆGoogleå…¨TLDã€Bingã€DuckDuckGoã€Yahooã€Yandexã€Baiduï¼‰
- ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡å®šã®ãƒ–ãƒ­ãƒƒã‚¯ãƒªã‚¹ãƒˆå¯¾å¿œ
- HTTPSã®ã¿è¨±å¯

#### 3. CrawlCandidateStack

å„ªå…ˆåº¦ä»˜ãã‚¯ãƒ­ãƒ¼ãƒ«å€™è£œã‚’ç®¡ç†ã™ã‚‹Actorã€‚

```swift
public actor CrawlCandidateStack {
    func push(_ candidate: CrawlCandidate)
    func push(_ candidates: [CrawlCandidate])
    func pop() -> CrawlCandidate?
    func pop(count: Int) -> [CrawlCandidate]
    func peek(count: Int) -> [CrawlCandidate]
    func contains(_ url: URL) -> Bool
    var count: Int { get async }
    var isEmpty: Bool { get async }
    func clear()
}
```

#### 4. CrawlContext

ä¸¦åˆ—ã‚¯ãƒ­ãƒ¼ãƒ«ã®å…±æœ‰çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ãªã‚¯ãƒ©ã‚¹ã€‚

```swift
public final class CrawlContext: @unchecked Sendable {
    // URLç®¡ç†
    func enqueueURLs(_ urls: [URL])      // URLã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ï¼ˆé‡è¤‡é™¤å¤–ï¼‰
    func dequeueURL() -> URL?            // æ¬¡ã®URLã‚’å–å¾—
    func completeURL(_ url: URL)         // å‡¦ç†å®Œäº†ã‚’è¨˜éŒ²
    func isVisited(_ url: URL) -> Bool   // è¨ªå•æ¸ˆã¿ãƒã‚§ãƒƒã‚¯

    // çµæœç®¡ç†
    func addResult(_ content: ReviewedContent)
    var reviewedContents: [ReviewedContent] { get }
    var relevantCount: Int { get }

    // å…±æœ‰æƒ…å ±ï¼ˆãƒ¬ãƒ“ãƒ¥ãƒ¼ç²¾åº¦å‘ä¸Šç”¨ï¼‰
    func getKnownFacts(limit: Int) -> [String]  // æ—¢çŸ¥äº‹å®Ÿã‚’å–å¾—
    func getRelevantDomains() -> Set<String>    // æœ‰ç”¨ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’å–å¾—

    // åˆ¶å¾¡
    func markSufficient()                // ååˆ†ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
    var isSufficient: Bool { get }
    var hasMoreURLs: Bool { get }

    // çµ±è¨ˆ
    func getStatistics() -> (processed: Int, relevant: Int, queued: Int, inProgress: Int)
}
```

#### 5. MemoryStorage

ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªã§ã‚¯ãƒ­ãƒ¼ãƒ«çµæœã‚’ä¿å­˜ã™ã‚‹Actorã€‚

```swift
public actor MemoryStorage {
    func store(_ content: CrawledContent)
    func store(_ newContents: [CrawledContent])
    func get(by id: UUID) -> CrawledContent?
    func get(by url: URL) -> CrawledContent?
    func getAll() -> [CrawledContent]
    func hasVisited(_ url: URL) -> Bool
    func markAsVisited(_ url: URL)
    var count: Int { get async }
    var visitedCount: Int { get async }
}
```

## ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«

### CrawlCandidate

```swift
public struct CrawlCandidate: Sendable, Comparable {
    let url: URL
    let score: Double          // 0.0ã€œ1.0ï¼ˆé«˜ã„ã»ã©å„ªå…ˆï¼‰
    let title: String?
    let reason: String?        // ã‚¹ã‚³ã‚¢ã®ç†ç”±
    let sourceURL: URL?        // ã“ã®ãƒªãƒ³ã‚¯ã‚’ç™ºè¦‹ã—ãŸãƒšãƒ¼ã‚¸
    let addedAt: Date
}
```

### CrawledContent

```swift
public struct CrawledContent: Identifiable, Sendable {
    let id: UUID
    let url: URL
    let title: String?
    let description: String?
    let markdown: String
    let links: [ExtractedLink]
    let crawledAt: Date
}

public struct ExtractedLink: Sendable, Hashable {
    let url: String
    let text: String?
}
```

### ReviewedContent

```swift
public struct ReviewedContent: Sendable {
    let url: URL
    let title: String?
    let extractedInfo: String  // æŠ½å‡ºã—ãŸé–¢é€£æƒ…å ±
    let isRelevant: Bool
}
```

### çµ±è¨ˆæƒ…å ±

```swift
public struct AggregatedStatistics: Sendable {
    let totalPagesVisited: Int   // è¨ªå•ã—ãŸãƒšãƒ¼ã‚¸ç·æ•°
    let relevantPagesFound: Int  // é–¢é€£ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ•°
    let keywordsUsed: Int
    let duration: Duration
}
```

### å‡ºåŠ›çµæœ

```swift
public struct AggregatedResult: Sendable {
    let objective: String
    let questions: [String]                 // ã‚½ã‚¯ãƒ©ãƒ†ã‚¹çš„è³ªå•
    let successCriteria: [String]           // å……è¶³åˆ¤å®šæ¡ä»¶
    let reviewedContents: [ReviewedContent] // ãƒ¬ãƒ“ãƒ¥ãƒ¼æ¸ˆã¿ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
    let responseMarkdown: String            // æœ€çµ‚å¿œç­”
    let keywordsUsed: [String]
    let statistics: AggregatedStatistics
}
```

## LLMãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ¢ãƒ‡ãƒ«ï¼ˆ@Generableï¼‰

### Phase 1: ObjectiveAnalysisResponse

```swift
@Generable
public struct ObjectiveAnalysisResponse: Sendable {
    let keywords: [String]        // æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    let questions: [String]       // ã‚½ã‚¯ãƒ©ãƒ†ã‚¹çš„è³ªå•
    let successCriteria: [String] // æˆåŠŸåŸºæº–
}
```

### Phase 3: ContentReviewResponse

```swift
@Generable
public struct ContentReviewResponse: Sendable {
    let isRelevant: Bool
    let extractedInfo: String
    let shouldDeepCrawl: Bool
    let priorityLinks: [PriorityLink]
}

@Generable
public struct PriorityLink: Sendable {
    let index: Int      // ãƒªãƒ³ã‚¯ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆ1å§‹ã¾ã‚Šï¼‰
    let score: Double   // é–¢é€£åº¦ã‚¹ã‚³ã‚¢
    let reason: String
}
```

### Phase 3.5: DeepCrawlReviewResponse

```swift
@Generable
public struct DeepCrawlReviewResponse: Sendable {
    let isRelevant: Bool
    let extractedInfo: String
    let shouldContinue: Bool  // æ·±æ˜ã‚Šç¶šè¡Œåˆ¤æ–­
    let reason: String
}
```

### Phase 4: SufficiencyCheckResponse

```swift
@Generable
public struct SufficiencyCheckResponse: Sendable {
    let isSufficient: Bool
    let shouldGiveUp: Bool
    let additionalKeywords: [String]
    let reasonMarkdown: String
}
```

### Phase 5: FinalResponseBuildingResponse

```swift
@Generable
public struct FinalResponseBuildingResponse: Sendable {
    let responseMarkdown: String
}
```

## è¨­å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³

```swift
public struct SearchConfiguration: Sendable {
    let searchEngine: SearchEngine      // .duckDuckGo, .google, .bing
    let requestDelay: Duration          // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: .milliseconds(500)
    let modelName: String               // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: "gpt-oss:20b"
    let baseURL: URL                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: http://127.0.0.1:11434
    let timeout: TimeInterval           // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 300.0
    let allowedDomains: [String]?       // nilã®å ´åˆã¯åˆ¶é™ãªã—
    let blockedDomains: [String]        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: []
}
```

## CLI ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

### åŸºæœ¬ã‚³ãƒãƒ³ãƒ‰

```bash
# ç›®çš„ãƒ™ãƒ¼ã‚¹ã®ãƒªã‚µãƒ¼ãƒï¼ˆæ¨å¥¨ï¼‰
research-cli "Swift Concurrency best practices"

# ã‚ªãƒ—ã‚·ãƒ§ãƒ³æŒ‡å®š
research-cli "Swift Concurrency" \
  --limit 100 \
  --model gpt-oss:20b \
  --format json \
  --verbose

# ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›
research-cli "Swift 6ã®æ–°æ©Ÿèƒ½" --log output.log
```

### ãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰

```bash
# æ¤œç´¢ã‚¹ãƒ†ãƒƒãƒ—ã®ãƒ†ã‚¹ãƒˆ
research-cli test-search "Swift Concurrency"

# ãƒ•ã‚§ãƒƒãƒã®ãƒ†ã‚¹ãƒˆ
research-cli test-fetch https://example.com
```

### å‡ºåŠ›ä¾‹

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ¯ Phase 0: INPUT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
objective: Swift Concurrency best practices
maxVisitedURLs: 100

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“Š Phase 1: OBJECTIVE ANALYSIS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
keywords: [Swift Concurrency best practices, async await patterns, ...]
questions: [What are the key patterns?, ...]
successCriteria: [Primary documentation found, ...]
â±ï¸ Phase 1 duration: 2.3s

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ” Phase 2: SEARCH [Swift Concurrency best practices]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Found 5 URLs:
  [1] https://example.com/swift-concurrency
  ...

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“„ Phase 3: PARALLEL CONTENT REVIEW
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   Queue: 10 URLs, Concurrency: 4
   [W0] â†’ example.com
   [W1] â†’ docs.swift.org
   [W2] â†’ hackingwithswift.com
   [W3] â†’ swiftbysundell.com
   [W0]    +2 deep URLs
   [W0] âœ“ 12.3s Swift Concurrency provides structured...
   [W1] âœ“ 15.7s Async/await allows non-blocking code...
   [W2]    +1 deep URLs
   [W2] âœ“ 18.2s The actor model prevents data races...
   [W3] Â· 20.1s (not relevant)

Phase 3 Summary: processed=10, relevant=7
â±ï¸ Phase 3 total: 45.2s

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âœ“ Phase 4: SUFFICIENCY CHECK
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
isSufficient: true
shouldGiveUp: false
â†’ SUFFICIENT, exiting loop

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“ Phase 5: RESPONSE BUILDING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
input reviewedContents: 5 items
output responseMarkdown: 2500 chars

ğŸ Complete!
   Visited: 8, Relevant: 5
   Keywords: 1
   Duration: 45.3s

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“Š Aggregated Crawl Results
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Œ Objective: Swift Concurrency best practices
ğŸ”‘ Keywords: Swift Concurrency best practices
â“ Questions: What are the key patterns? / ...
âœ“ Criteria: Primary documentation found / ...

ğŸ“ˆ Statistics:
   â€¢ Pages visited: 8
   â€¢ Relevant pages: 5
   â€¢ Keywords used: 1
   â€¢ Duration: 45s

ğŸ“ Response:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Swift Concurrency Best Practices
...
```

## ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

### SearchError

```swift
public enum SearchError: Error, Sendable {
    case searchFailed(String)
    case fetchFailed(URL, String)
    case modelUnavailable
    case invalidConfiguration(String)
    case timeout
    case noURLsFound
    case invalidURL(String)
    case cancelled
}
```

## ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ

```
Sources/
â”œâ”€â”€ SwiftResearch/
â”‚   â”œâ”€â”€ AgenticCrawler.swift              # ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆ
â”‚   â”œâ”€â”€ Models/
â”‚   â”‚   â”œâ”€â”€ AnalysisResponse.swift        # @Generable LLMãƒ¬ã‚¹ãƒãƒ³ã‚¹
â”‚   â”‚   â”œâ”€â”€ CrawlCandidate.swift          # å„ªå…ˆåº¦ä»˜ãå€™è£œ + CrawlCandidateStack
â”‚   â”‚   â”œâ”€â”€ CrawlContext.swift            # ä¸¦åˆ—ã‚¯ãƒ­ãƒ¼ãƒ«å…±æœ‰çŠ¶æ…‹ï¼ˆNEWï¼‰
â”‚   â”‚   â”œâ”€â”€ CrawledContent.swift          # ã‚¯ãƒ­ãƒ¼ãƒ«æ¸ˆã¿ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
â”‚   â”‚   â”œâ”€â”€ SearchError.swift            # ã‚¨ãƒ©ãƒ¼å®šç¾©
â”‚   â”‚   â”œâ”€â”€ CrawlerInput.swift            # è¨­å®šãƒ»å…¥åŠ›ãƒ¢ãƒ‡ãƒ«
â”‚   â”‚   â”œâ”€â”€ CrawlerResult.swift           # çµæœãƒ¢ãƒ‡ãƒ«ï¼ˆæ—§ã€å‚è€ƒç”¨ï¼‰
â”‚   â”‚   â””â”€â”€ StepModels.swift              # Stepå…¥å‡ºåŠ›ãƒ¢ãƒ‡ãƒ«
â”‚   â”œâ”€â”€ Steps/
â”‚   â”‚   â”œâ”€â”€ SearchOrchestratorStep.swift  # 5ãƒ•ã‚§ãƒ¼ã‚ºã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼ˆä¸¦åˆ—å¯¾å¿œï¼‰
â”‚   â”‚   â””â”€â”€ SearchStep.swift              # æ¤œç´¢Step
â”‚   â””â”€â”€ Storage/
â”‚       â””â”€â”€ MemoryStorage.swift           # ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸
â””â”€â”€ ResearchCLI/
    â””â”€â”€ ResearchCLI.swift                 # CLIã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆ

Tests/
â””â”€â”€ SwiftResearchTests/
    â””â”€â”€ MemoryStorageTests.swift
```

## è¨­è¨ˆåŸå‰‡

### ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯çµ‚äº†æ¡ä»¶

å¾“æ¥ã®ã‚¯ãƒ­ãƒ¼ãƒ©ãƒ¼ã¯å›ºå®šåˆ¶é™ã§çµ‚äº†ã‚’åˆ¶å¾¡ã—ã¾ã™ãŒã€SwiftResearchã¯**LLMã«ã‚ˆã‚‹ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯å……è¶³åº¦åˆ¤å®š**ã‚’æ¡ç”¨ã—ã¦ã„ã¾ã™ã€‚

- ã€Œç›®çš„ã«å¯¾ã—ã¦ååˆ†ãªæƒ…å ±ãŒé›†ã¾ã£ãŸã‹ã€ã‚’LLMãŒåˆ¤æ–­
- ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®æ•°ã‚‚ã€æ¤œç´¢çµæœã®æ•°ã‚‚ã€LLMãŒé©åˆ‡ã¨åˆ¤æ–­ã™ã‚‹é‡ã‚’ä½¿ç”¨
- ä¸è¶³æƒ…å ±ã‚’ç‰¹å®šã—ã€è¿½åŠ ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’è‡ªå‹•ç”Ÿæˆ
- ç„¡é–¢ä¿‚ãªãƒšãƒ¼ã‚¸ã¯æ—©æœŸã‚¹ã‚­ãƒƒãƒ—ï¼ˆãƒªã‚½ãƒ¼ã‚¹ç¯€ç´„ï¼‰

### ã‚»ãƒ¼ãƒ•ãƒ†ã‚£ãƒªãƒŸãƒƒãƒˆ

`maxVisitedURLs`ï¼ˆCLI: `--limit`ï¼‰ã¯**ã‚»ãƒ¼ãƒ•ãƒ†ã‚£ãƒªãƒŸãƒƒãƒˆ**ã¨ã—ã¦æ©Ÿèƒ½ã—ã¾ã™ã€‚ã“ã‚Œã¯LLMã®åˆ¤æ–­ãƒŸã‚¹ã‚„ç„¡é™ãƒ«ãƒ¼ãƒ—ã‚’é˜²ããŸã‚ã®å®‰å…¨å¼ã§ã‚ã‚Šã€é€šå¸¸ã®çµ‚äº†æ¡ä»¶ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤: 100
- LLMãŒå……è¶³ã¨åˆ¤æ–­ã™ã‚‹å‰ã«ã“ã®ä¸Šé™ã«é”ã—ãŸå ´åˆã€ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’å¼·åˆ¶çµ‚äº†
- é€šå¸¸ã¯ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯å……è¶³åº¦åˆ¤å®šãŒå…ˆã«åƒã„ã¦çµ‚äº†ã™ã‚‹

### AMD Frameworkå‚ç…§

ç›®çš„åˆ†æï¼ˆPhase 1ï¼‰ã§ã¯ã€AMD Framework (arXiv:2502.08557) ã«åŸºã¥ãã‚½ã‚¯ãƒ©ãƒ†ã‚¹çš„è³ªå•åˆ†è§£ã‚’æ¡ç”¨ã—ã¦ã„ã¾ã™ã€‚

- **æ˜ç¢ºåŒ–**: ä½•ã‚’æ„å‘³ã—ã¦ã„ã‚‹ã‹ï¼Ÿ
- **å‰ææ¤œè¨¼**: ä½•ã‚’å‰æã¨ã—ã¦ã„ã‚‹ã‹ï¼Ÿ
- **å«æ„æ¢ç´¢**: ä½•ãŒå°ã‹ã‚Œã‚‹ã‹ï¼Ÿ

### ä¸¦åˆ—å‡¦ç†ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

Phase 3ã§ã¯ã€è¤‡æ•°ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒä¸¦åˆ—ã§URLã‚’å‡¦ç†ã—ã¾ã™ã€‚

#### CrawlContextï¼ˆå…±æœ‰çŠ¶æ…‹ï¼‰

- **ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•**: NSLockã«ã‚ˆã‚‹æ’ä»–åˆ¶å¾¡
- **URLã‚­ãƒ¥ãƒ¼**: è¨ªå•æ¸ˆã¿URLã®è‡ªå‹•é™¤å¤–ã€å‹•çš„ãªDeepCrawl URLè¿½åŠ 
- **æ—¢çŸ¥äº‹å®Ÿï¼ˆknownFactsï¼‰**: å„ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒæŠ½å‡ºã—ãŸæƒ…å ±ã‚’å…±æœ‰ã—ã€é‡è¤‡æŠ½å‡ºã‚’é˜²æ­¢
- **æœ‰ç”¨ãƒ‰ãƒ¡ã‚¤ãƒ³å­¦ç¿’**: 2å›ä»¥ä¸Šé–¢é€£ãƒšãƒ¼ã‚¸ãŒè¦‹ã¤ã‹ã£ãŸãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’è¿½è·¡

#### ãƒ¯ãƒ¼ã‚«ãƒ¼å‹•ä½œ

```
while (url = context.dequeueURL()) {
    if context.isSufficient { break }

    content = await fetch(url)
    knownFacts = context.getKnownFacts(limit: 5)

    review = await llm.review(content, knownFacts: knownFacts)
    context.addResult(review)

    if review.shouldDeepCrawl {
        context.enqueueURLs(review.priorityLinks)
    }

    context.completeURL(url)
}
```

#### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åŠ¹æœ

- **ä¸¦åˆ—å‡¦ç†**: 4ãƒ¯ãƒ¼ã‚«ãƒ¼åŒæ™‚å®Ÿè¡Œã§å‡¦ç†æ™‚é–“ã‚’ç´„50%å‰Šæ¸›
- **æ—¢çŸ¥äº‹å®Ÿå…±æœ‰**: é‡è¤‡æƒ…å ±ã®æŠ½å‡ºã‚’é˜²ãã€LLMã‚³ã‚¹ãƒˆã‚’å‰Šæ¸›
- **å‹•çš„ã‚­ãƒ¥ãƒ¼**: DeepCrawl URLã‚’å³åº§ã«ä»–ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒå‡¦ç†å¯èƒ½

### æ·±æ˜ã‚Šï¼ˆDeepCrawlï¼‰ã®åˆ¶å¾¡

Phase 3ã§ã¯ã€é–¢é€£æ€§ã®é«˜ã„ãƒšãƒ¼ã‚¸ã‹ã‚‰ç™ºè¦‹ã•ã‚ŒãŸãƒªãƒ³ã‚¯ã‚’æ·±æ˜ã‚Šã—ã¾ã™ã€‚LLMãŒå±¥æ­´ã‚’è€ƒæ…®ã—ã¦ç¶šè¡Œåˆ¤æ–­ã‚’è¡Œã„ã€ç„¡é–¢ä¿‚ãªãƒšãƒ¼ã‚¸ã‹ã‚‰ã®ãƒªãƒ³ã‚¯ã¯æ—©æœŸã«æ‰“ã¡åˆ‡ã‚Šã¾ã™ã€‚

## ä»Šå¾Œã®æ‹¡å¼µäºˆå®š

1. **æ°¸ç¶šåŒ–ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸** - SQLite/CoreDataå¯¾å¿œ
2. **ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ©Ÿèƒ½** - å–å¾—æ¸ˆã¿ãƒšãƒ¼ã‚¸ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
3. **ãƒ¬ãƒ¼ãƒˆåˆ¶é™** - ãƒ‰ãƒ¡ã‚¤ãƒ³ã”ã¨ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆåˆ¶é™
4. **èªè¨¼å¯¾å¿œ** - Basicèªè¨¼/OAuthå¯¾å¿œã‚µã‚¤ãƒˆã®ã‚¯ãƒ­ãƒ¼ãƒ«
5. **JavaScriptå¯¾å¿œ** - SPAã‚µã‚¤ãƒˆã®ã‚¯ãƒ­ãƒ¼ãƒ«ï¼ˆWebKitçµ±åˆï¼‰
6. **ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°** - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ çµæœè¡¨ç¤º
