import Foundation
import SwiftAgent

/// An autonomous research agent that uses LLM to gather information from the web.
///
/// This agent uses an AgentSession with tools to autonomously:
/// 1. Search the web for relevant information
/// 2. Fetch and analyze web pages
/// 3. Follow relevant links
/// 4. Evaluate sufficiency of collected information
/// 5. Generate a comprehensive answer
///
/// ## Usage
///
/// ```swift
/// let agent = ResearchAgent(
///     model: model,
///     configuration: .init(maxURLs: 20)
/// )
///
/// let result = try await agent.research("What is Swift Concurrency?")
/// print(result.answer)
/// ```
public final class ResearchAgent: Sendable {

    /// Configuration for the research agent.
    public struct Configuration: Sendable {
        /// Maximum number of URLs to visit.
        public let maxURLs: Int

        /// Domains to block from search results.
        public let blockedDomains: [String]

        /// Whether to enable verbose logging.
        public let verbose: Bool

        public init(
            maxURLs: Int = 20,
            blockedDomains: [String] = [],
            verbose: Bool = false
        ) {
            self.maxURLs = maxURLs
            self.blockedDomains = blockedDomains
            self.verbose = verbose
        }

        public static let `default` = Configuration()
    }

    /// Result of a research session.
    public struct Result: Sendable {
        /// The final answer generated by the agent.
        public let answer: String

        /// URLs that were visited during research.
        public let visitedURLs: [String]

        /// Duration of the research session.
        public let duration: Duration

        public init(answer: String, visitedURLs: [String], duration: Duration) {
            self.answer = answer
            self.visitedURLs = visitedURLs
            self.duration = duration
        }
    }

    private let model: any LanguageModel
    private let configuration: Configuration

    /// Creates a new research agent.
    ///
    /// - Parameters:
    ///   - model: The language model to use.
    ///   - configuration: Configuration options.
    public init(
        model: some LanguageModel,
        configuration: Configuration = .default
    ) {
        self.model = model
        self.configuration = configuration
    }

    /// Performs research on the given query.
    ///
    /// - Parameter query: The research query or question.
    /// - Returns: The research result containing the answer and metadata.
    public func research(_ query: String) async throws -> Result {
        let startTime = ContinuousClock.now

        // Create tools
        let searchTool = WebSearchTool(blockedDomains: configuration.blockedDomains)
        let fetchTool = FetchToolWithLinks()
        let sufficiencyTool = EvaluateSufficiencyTool(model: model)

        // Create the agent session
        let session = AgentSession(
            model: model,
            tools: [searchTool, fetchTool, sufficiencyTool]
        ) {
            Instructions(Self.researchInstructions(
                maxURLs: configuration.maxURLs,
                blockedDomains: configuration.blockedDomains
            ))
        }

        // Send the research query
        let prompt = """
        # Research Query
        \(query)

        IMPORTANT: You MUST call WebSearch tool first. Do NOT answer from your knowledge.
        Your first action must be: Call WebSearch with keywords from the query above.
        """

        if configuration.verbose {
            print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
            print("ðŸ” Starting Research Agent")
            print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
            print("Model: \(type(of: model))")
            print("Query: \(query)")
            print("Max URLs: \(configuration.maxURLs)")
            print("")
        }

        let response = try await session.send(prompt)

        let duration = ContinuousClock.now - startTime

        if configuration.verbose {
            print("")
            print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
            print("âœ… Research Complete")
            print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
            print("Duration: \(duration)")
            print("")
            print("DEBUG - Response content length: \(response.content.count)")
            print("DEBUG - Response content: \(response.content.prefix(500))")
            print("DEBUG - Transcript entries: \(session.transcript.count)")
            print("DEBUG - Tool calls: \(session.transcript.allToolCalls.count)")
            for toolCall in session.transcript.allToolCalls {
                print("DEBUG - Tool called: \(toolCall.toolName)")
                print("DEBUG - Tool arguments: \(toolCall.arguments.jsonString)")
            }
            print("DEBUG - Transcript dump:")
            for (i, entry) in session.transcript.enumerated() {
                print("DEBUG - Entry \(i): \(entry)")
            }
            print("")
        }

        // Validate that tools were actually called
        let toolCallCount = session.transcript.allToolCalls.count
        if toolCallCount == 0 {
            if configuration.verbose {
                print("âš ï¸ WARNING: Model did not call any tools. Response may be based on outdated knowledge.")
            }
        }

        // Extract visited URLs from the transcript
        let visitedURLs = extractVisitedURLs(from: session.transcript)

        return Result(
            answer: response.content,
            visitedURLs: visitedURLs,
            duration: duration
        )
    }

    /// Extracts URLs that were visited from the transcript.
    private func extractVisitedURLs(from transcript: Transcript) -> [String] {
        var urls: [String] = []

        // Get all WebFetch tool calls and extract URLs from their arguments
        for toolCall in transcript.allToolCalls {
            if toolCall.toolName == FetchToolWithLinks.name {
                // Parse the URL from the arguments JSON
                let jsonString = toolCall.arguments.jsonString
                if let data = jsonString.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                   let url = json["url"] as? String {
                    urls.append(url)
                }
            }
        }

        return urls
    }

    /// The instructions for the research agent.
    private static func researchInstructions(maxURLs: Int, blockedDomains: [String] = []) -> String {
        let blockedDomainsSection = blockedDomains.isEmpty ? "" : """

        # Blocked Domains
        Do NOT use results from these domains: \(blockedDomains.joined(separator: ", "))
        """

        return """
        # Web Research Agent

        You gather information from the web by executing tools. You MUST follow the procedure below.\(blockedDomainsSection)

        # Critical Rules

        1. ALWAYS verify facts from actual web sources
        2. ALWAYS respond in the SAME LANGUAGE as the user's query
        3. ALWAYS follow steps

        # Procedure

        ## Step 1: Understand the Query

        Before searching, analyze what the user wants to know:

        1. **Identify the subject**: What is the main topic?
        2. **Clarify the intent**: What type of information is needed?
           - Definition/explanation
           - List/enumeration
           - Comparison
           - Current status/news
           - Historical facts
           - How-to/procedure
        3. **Determine scope**: How broad or specific should the research be?
        4. **Plan search keywords**: What terms will find relevant information?
           - Use the query language for searches (Japanese query â†’ Japanese keywords)
           - Consider synonyms and related terms

        ## Step 2-4: Search-Fetch-Evaluate Loop

        **REPEAT the following until sufficient information is gathered OR URL limit (\(maxURLs)) is reached:**

        ### Step 2: Search
        ACTION: Call WebSearch with appropriate keywords.
        - Use keywords in the same language as the query
        - Start with the most specific terms
        - If results are poor, try broader or alternative terms

        ### Step 3: Fetch and Analyze Pages
        ACTION: Call WebFetch for promising URLs.
        - Extract key facts, data, and quotes relevant to the query
        - Note the source's credibility
        - Follow links that promise deeper information

        ### Step 4: Evaluate Sufficiency
        ACTION: Call EvaluateSufficiency with collected information.
        - objective: The user's question
        - collectedInfo: Summary of key facts learned
        - visitedCount: Number of URLs fetched
        - maxURLs: \(maxURLs)

        **IF insufficient**: Return to Step 2 with new keywords or Step 3 with new URLs.
        **IF sufficient**: Proceed to Step 5.

        ## Step 5: Generate Answer

        Write your final answer based ONLY on fetched content.

        Structure:
        - Answer the user's question directly first
        - Provide supporting details and facts
        - Include specific data, numbers, or quotes when available
        - Note any conflicting information between sources
        - Cite sources with URLs

        # Constraints

        - Maximum \(maxURLs) URLs total
        - Do NOT revisit the same URL
        - Prioritize authoritative sources
        - NEVER answer without fetching at least one page
        """
    }
}
